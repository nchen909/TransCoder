{"repo": "rails/rails", "path": "activerecord/lib/active_record/relation/batches.rb", "func_name": "ActiveRecord.Batches.find_in_batches", "original_string": "def find_in_batches(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil)\n      relation = self\n      unless block_given?\n        return to_enum(:find_in_batches, start: start, finish: finish, batch_size: batch_size, error_on_ignore: error_on_ignore) do\n          total = apply_limits(relation, start, finish).size\n          (total - 1).div(batch_size) + 1\n        end\n      end\n\n      in_batches(of: batch_size, start: start, finish: finish, load: true, error_on_ignore: error_on_ignore) do |batch|\n        yield batch.to_a\n      end\n    end", "language": "ruby", "code": "def find_in_batches(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil)\n      relation = self\n      unless block_given?\n        return to_enum(:find_in_batches, start: start, finish: finish, batch_size: batch_size, error_on_ignore: error_on_ignore) do\n          total = apply_limits(relation, start, finish).size\n          (total - 1).div(batch_size) + 1\n        end\n      end\n\n      in_batches(of: batch_size, start: start, finish: finish, load: true, error_on_ignore: error_on_ignore) do |batch|\n        yield batch.to_a\n      end\n    end", "code_tokens": ["def", "find_in_batches", "(", "start", ":", "nil", ",", "finish", ":", "nil", ",", "batch_size", ":", "1000", ",", "error_on_ignore", ":", "nil", ")", "relation", "=", "self", "unless", "block_given?", "return", "to_enum", "(", ":find_in_batches", ",", "start", ":", "start", ",", "finish", ":", "finish", ",", "batch_size", ":", "batch_size", ",", "error_on_ignore", ":", "error_on_ignore", ")", "do", "total", "=", "apply_limits", "(", "relation", ",", "start", ",", "finish", ")", ".", "size", "(", "total", "-", "1", ")", ".", "div", "(", "batch_size", ")", "+", "1", "end", "end", "in_batches", "(", "of", ":", "batch_size", ",", "start", ":", "start", ",", "finish", ":", "finish", ",", "load", ":", "true", ",", "error_on_ignore", ":", "error_on_ignore", ")", "do", "|", "batch", "|", "yield", "batch", ".", "to_a", "end", "end"], "docstring": "Yields each batch of records that was found by the find options as\n an array.\n\n   Person.where(\"age > 21\").find_in_batches do |group|\n     sleep(50) # Make sure it doesn't get too crowded in there!\n     group.each { |person| person.party_all_night! }\n   end\n\n If you do not provide a block to #find_in_batches, it will return an Enumerator\n for chaining with other methods:\n\n   Person.find_in_batches.with_index do |group, batch|\n     puts \"Processing group ##{batch}\"\n     group.each(&:recover_from_last_night!)\n   end\n\n To be yielded each record one by one, use #find_each instead.\n\n ==== Options\n * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000.\n * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.\n * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.\n * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when\n   an order is present in the relation.\n\n Limits are honored, and if present there is no requirement for the batch\n size: it can be less than, equal to, or greater than the limit.\n\n The options +start+ and +finish+ are especially useful if you want\n multiple workers dealing with the same processing queue. You can make\n worker 1 handle all the records between id 1 and 9999 and worker 2\n handle from 10000 and beyond by setting the +:start+ and +:finish+\n option on each worker.\n\n   # Let's process from record 10_000 on.\n   Person.find_in_batches(start: 10_000) do |group|\n     group.each { |person| person.party_all_night! }\n   end\n\n NOTE: It's not possible to set the order. That is automatically set to\n ascending on the primary key (\"id ASC\") to make the batch ordering\n work. This also means that this method only works when the primary key is\n orderable (e.g. an integer or string).\n\n NOTE: By its nature, batch processing is subject to race conditions if\n other processes are modifying the database.", "docstring_tokens": ["Yields", "each", "batch", "of", "records", "that", "was", "found", "by", "the", "find", "options", "as", "an", "array", "."], "sha": "85a8bc644be69908f05740a5886ec19cd3679df5", "url": "https://github.com/rails/rails/blob/85a8bc644be69908f05740a5886ec19cd3679df5/activerecord/lib/active_record/relation/batches.rb#L126-L138", "partition": "train"}